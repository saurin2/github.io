
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>LeetCode 662 — Maximum Width of Binary Tree (Micro-steps)</title>
<style>
  :root {
    --bg: #fff; --fg: #111; --muted: #666;
    --accent1: #1f77b4; --accent2: #ff7f0e; --accent3: #2ca02c;
    --box: #222;
  }
  body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 20px; color: var(--fg); background: var(--bg); }
  .container { max-width: 1280px; margin: 0 auto; }
  h2 { margin-bottom: 6px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin: 12px 0; }
  input[type="text"] { padding: 6px 8px; min-width: 360px; }
  select, button { padding: 6px 10px; font-size: 14px; }
  .status { margin-left: 6px; }
  .layout { display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 16px; align-items: start; }
  .panel { border: 1px solid #ddd; padding: 10px; border-radius: 10px; background:#fafafa; }
  .panel h3 { margin: 8px 0; font-size: 16px; }

  .treeCanvas { position: relative; }
  .tree { padding: 10px; border-radius: 10px; }
  .level { display:grid; gap: 12px; align-items:center; margin: 8px 0; }
  .node {
    width: 42px; height: 42px; border-radius: 50%;
    border: 2px solid var(--box);
    display:flex; align-items:center; justify-content:center;
    font-weight:600; background: #fff;
    margin:0 auto; position: relative;
    transition: transform .15s;
  }
  .node.current { outline: 3px solid var(--accent3); transform: scale(1.04); background: #f6fff6; }
  .node.enq { box-shadow: 0 0 0 3px var(--accent1) inset; }
  .slot { min-height: 52px; }
  .legend { font-size: 12px; color: #555; margin-top: 8px; }

  .vars { display:grid; grid-template-columns: 1fr 1fr; gap: 6px; }
  .vrow { display:flex; justify-content: space-between; background:#fff; border:1px solid #ddd; border-radius:6px; padding:6px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .que { display:flex; gap:8px; flex-wrap:wrap; }
  .qitem { border:1px solid #aaa; padding:4px 8px; border-radius:6px; background:#fff; }
  .qidx { color: var(--muted); margin-left:4px; }
  .sep { color: var(--muted); }

  /* Code box: prevent wrapping, horizontal scroll if needed */
  .codebox { background:#0c0f14; color:#cde3ff; border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px;
             overflow-x: auto; }
  .codeline { display: grid; grid-template-columns: 32px 18px auto; gap: 8px; align-items: start; padding: 2px 6px; border-radius: 6px; }
  .codeline .ln { color:#7799bb; text-align: right; }
  .codeline .ptr { width: 18px; text-align: center; color: #9cff57; }
  .codeline .code-text { white-space: pre; }
  .codeline.active { background: #122033; }
  .codeline.hint { background: #0f1723; }

  .svg-lines { position:absolute; left:0; top:0; pointer-events:none; }
  .micro { margin-left: 8px; font-size: 14px; }
</style>
</head>
<body>
<div class="container">
  <h2>LeetCode 662 — Maximum Width of Binary Tree (Micro-steps)</h2>
  <div class="row">
    <label><strong>Choose test case:</strong>
      <select id="preset">
        <option value="ex1">Example 1: [1,3,2,5,3,null,9] → expected 4</option>
        <option value="ex2">Example 2: [1,3,null,5,3] → expected 2</option>
        <option value="ex3">Example 3: [1,3,2,5] → expected 2</option>
        <option value="custom">Custom</option>
      </select>
    </label>
    <input id="arr" type="text" value="[1,3,2,5,3,null,9]" />
    <button id="load">Load</button>
    <label class="micro"><input type="checkbox" id="micro" checked> Micro-steps inside for-loop</label>
    <span id="err" style="color:#b00;"></span>
  </div>

  <div class="controls">
    <button id="first">&laquo; First</button>
    <button id="prev">&lsaquo; Prev</button>
    <span class="status" id="status">Step 0 / 0</span>
    <button id="next">Next &rsaquo;</button>
    <button id="last">Last &raquo;</button>
    <button id="play">Play</button>
    <label style="margin-left:10px;">Speed <input id="speed" type="range" min="150" max="1500" step="50" value="600"></label>
  </div>

  <div class="layout">
    <!-- Left: tree + state -->
    <div>
      <div class="panel">
        <h3>Tree (complete-binary layout by index)</h3>
        <div class="treeCanvas" id="treeCanvas">
          <div id="tree" class="tree"></div>
          <svg id="lines" class="svg-lines"></svg>
        </div>
        <div class="legend">Root at 0, left = 2i+1, right = 2i+2. Empty slots keep spacing like the LeetCode images.</div>
      </div>

      <div class="panel">
        <h3>State</h3>
        <div class="vars">
          <div class="vrow"><span>size</span><span id="v_size">-</span></div>
          <div class="vrow"><span>first</span><span id="v_first">-</span></div>
          <div class="vrow"><span>last</span><span id="v_last">-</span></div>
          <div class="vrow"><span>maxwidth</span><span id="v_max">-</span></div>
          <div class="vrow"><span>current idx</span><span id="v_idx">-</span></div>
          <div class="vrow"><span>current val</span><span id="v_val">-</span></div>
          <div class="vrow"><span>phase</span><span id="v_phase">-</span></div>
          <div class="vrow"><span>substep</span><span id="v_sub">-</span></div>
        </div>
        <div style="margin-top:8px;">
          <div><span class="em">Queue</span> (value, idx):</div>
          <div class="que" id="queue"></div>
        </div>
      </div>
    </div>

    <!-- Right: code + notes -->
    <div>
      <div class="panel">
        <h3>Code (gdb-style pointer)</h3>
        <div id="code" class="codebox"></div>
      </div>
      <div class="panel">
        <h3>Notes</h3>
        <div id="note" class="vrow" style="display:block;">—</div>
        <div style="margin-top:8px;">
          <span class="em">Formula this level:</span>
          <span class="vrow" id="formula" style="display:inline-block; background:#fff;">width = last - first + 1 → <span id="formulaEval">—</span></span>
        </div>
      </div>
    </div>
  </div>

  <div class="legend" style="margin-top:10px;">Examples from the LeetCode statement. Simulation mirrors the provided C++ BFS with complete-tree indexing. Micro-steps split the for-loop body into individual statements.</div>
</div>

<script>
// ===== Presets =====
const PRESETS = {
  ex1: "[1,3,2,5,3,null,9]",
  ex2: "[1,3,null,5,3]",
  ex3: "[1,3,2,5]"
};

// ===== Code lines for pointer (C++ pretty-printed) =====
const CODE_LINES = [
  "if (!root) return 0;",
  "using ULL = unsigned long long;",
  "queue<pair<TreeNode*,ULL>> q;",
  "ULL maxwidth = 0;",
  "q.push({root, 0});",
  "while (!q.empty()) {",
  "    ULL first = 0, last = 0;",
  "    int size = q.size();",
  "    for (int i = 0; i < size; i++) {",
  "        auto [node, idx] = q.front(); q.pop();",
  "        if (i == 0) first = idx;",
  "        if (i == size - 1) last = idx;",
  "        if (node->left)  q.push({node->left,  idx * 2 + 1});",
  "        if (node->right) q.push({node->right, idx * 2 + 2});",
  "    }",
  "    maxwidth = max(maxwidth, last - first + 1);",
  "}",
  "return static_cast<int>(maxwidth);"
];

// ===== Parse helpers =====
function parseArray(text) {
  try {
    let t = text.trim();
    if (!t.startsWith("[")) t = "[" + t + "]";
    const arr = JSON.parse(t.replace(/\\bnull\\b/g, "null"));
    if (!Array.isArray(arr)) return null;
    return arr;
  } catch { return null; }
}

// Build index->value map
function buildIndexMap(arr) {
  const map = new Map();
  arr.forEach((v, i) => { if (v !== null && v !== undefined) map.set(i, v); });
  return map;
}

// ===== Build steps (micro or normal) =====
function buildSteps(arr, micro) {
  const idxMap = buildIndexMap(arr);
  if (!idxMap.has(0)) {
    return [{note:"Empty tree", tree:idxMap, queue:[], size:0, first:null, last:null, maxw:0, phase:"done", done:true}];
  }
  const q = [{idx:0, val: idxMap.get(0)}];
  const steps = [];
  let maxw = 0;

  while (q.length) {
    const size = q.length;
    let first = 0, last = 0;

    steps.push({
      note:`Start level: size=${size}`,
      tree:new Map(idxMap), queue:q.slice(), size, first:null, last:null, maxw,
      highlight:null, enq:[], phase:"level-start", sub:null, curIdx:null, curVal:null, done:false
    });

    for (let i=0;i<size;i++) {
      // Dequeue
      const {idx, val} = q.shift();

      if (micro) {
        steps.push({
          note:`Dequeue -> (val=${val}, idx=${idx})`,
          tree:new Map(idxMap), queue:q.slice(), size, first:(i===0? idx : first), last:(i===size-1? idx : last), maxw,
          highlight:idx, enq:[], phase:"process", sub:"deq", curIdx:idx, curVal:val, i
        });
      }

      // first
      if (i === 0) first = idx;
      if (micro) {
        steps.push({
          note:(i===0? `Set first = idx = ${idx}` : `Skip first (i=${i})`),
          tree:new Map(idxMap), queue:q.slice(), size, first, last, maxw,
          highlight:idx, enq:[], phase:"process", sub:"first", curIdx:idx, curVal:val, i
        });
      }

      // last
      if (i === size-1) last = idx;
      if (micro) {
        steps.push({
          note:(i===size-1? `Set last = idx = ${idx}` : `Skip last (i=${i} != size-1)`),
          tree:new Map(idxMap), queue:q.slice(), size, first, last, maxw,
          highlight:idx, enq:[], phase:"process", sub:"last", curIdx:idx, curVal:val, i
        });
      }

      // enqueue left
      const li = 2*idx + 1, ri = 2*idx + 2;
      let enqL = false, enqR = false;
      if (idxMap.has(li)) { q.push({idx:li, val: idxMap.get(li)}); enqL = true; }
      if (micro) {
        steps.push({
          note: enqL ? `Enqueue left child at idx=${li}` : `No left child`,
          tree:new Map(idxMap), queue:q.slice(), size, first, last, maxw,
          highlight:idx, enq: enqL ? [li] : [], phase:"process", sub:"enqL", curIdx:idx, curVal:val, i
        });
      }

      // enqueue right
      if (idxMap.has(ri)) { q.push({idx:ri, val: idxMap.get(ri)}); enqR = true; }
      if (micro) {
        steps.push({
          note: enqR ? `Enqueue right child at idx=${ri}` : `No right child`,
          tree:new Map(idxMap), queue:q.slice(), size, first, last, maxw,
          highlight:idx, enq: enqR ? [ri] : [], phase:"process", sub:"enqR", curIdx:idx, curVal:val, i
        });
      }

      if (!micro) {
        // classic single-step per node
        const enq = [];
        if (enqL) enq.push(li);
        if (enqR) enq.push(ri);
        steps.push({
          note:`Process node (val=${val}, idx=${idx})` + (enq.length ? `; enqueue [${enq.join(", ")}]` : "; no children"),
          tree:new Map(idxMap), queue:q.slice(), size, first, last, maxw, highlight:idx, enq, phase:"process", sub:null, curIdx:idx, curVal:val, i
        });
      }
    }
    const width = last - first + 1;
    maxw = Math.max(maxw, width);
    steps.push({
      note:`End level → width=${last}-${first}+1=${width}; max=${maxw}`,
      tree:new Map(idxMap), queue:q.slice(), size, first, last, maxw, highlight:null, enq:[], phase:"level-end", sub:null, done:false
    });
  }
  steps.push({note:`Done. Maximum width = ${maxw}`, tree:new Map(buildIndexMap(arr)), queue:[], size:0, first:null, last:null, maxw, phase:"done", sub:null, done:true});
  return steps;
}

// ===== DOM Refs =====
const presetSel = document.getElementById('preset');
const arrInput = document.getElementById('arr');
const microChk = document.getElementById('micro');
const loadBtn = document.getElementById('load');
const statusEl = document.getElementById('status');

const treeCanvas = document.getElementById('treeCanvas');
const treeEl = document.getElementById('tree');
const linesSvg = document.getElementById('lines');

const queueEl = document.getElementById('queue');
const vSize = document.getElementById('v_size');
const vFirst = document.getElementById('v_first');
const vLast = document.getElementById('v_last');
const vMax = document.getElementById('v_max');
const vIdx = document.getElementById('v_idx');
const vVal = document.getElementById('v_val');
const vPhase = document.getElementById('v_phase');
const vSub = document.getElementById('v_sub');
const noteEl = document.getElementById('note');
const formulaEvalEl = document.getElementById('formulaEval');
const codeEl = document.getElementById('code');

// Build code panel
function buildCode() {
  codeEl.innerHTML = "";
  CODE_LINES.forEach((txt, i) => {
    const d = document.createElement('div');
    d.className = 'codeline';
    d.dataset.ln = (i+1);
    d.innerHTML = `<div class="ln">${i+1}</div><div class="ptr"> </div><div class="code-text">${txt}</div>`;
    codeEl.appendChild(d);
  });
}
buildCode();

function setPointer(line, hints=[]) {
  const lines = codeEl.querySelectorAll('.codeline');
  lines.forEach(l => { l.classList.remove('active','hint'); l.querySelector('.ptr').textContent = ' '; });
  if (line != null) {
    const el = codeEl.querySelector(`.codeline[data-ln="${line}"]`);
    if (el) { el.classList.add('active'); el.querySelector('.ptr').textContent = '›'; }
  }
  hints.forEach(h => {
    const el = codeEl.querySelector(`.codeline[data-ln="${h}"]`);
    if (el) el.classList.add('hint');
  });
}

// Pointer mapping: exact statement lines in micro mode
function pointerForStep(s, micro) {
  if (s.done) return {line:18, hints:[]};
  if (s.phase === 'level-start') return {line:8, hints:[6,7]};
  if (s.phase === 'process') {
    if (micro) {
      if (s.sub === 'deq')   return {line:10, hints:[9]};
      if (s.sub === 'first') return {line:11, hints:[9]};
      if (s.sub === 'last')  return {line:12, hints:[9]};
      if (s.sub === 'enqL')  return {line:13, hints:[9]};
      if (s.sub === 'enqR')  return {line:14, hints:[9]};
      return {line:9, hints:[]};
    } else {
      // classic: keep pointer on for header, show body as hints
      const hints = [10,11,12];
      if (s.enq && s.enq.length) hints.push(13,14);
      return {line:9, hints};
    }
  }
  if (s.phase === 'level-end') return {line:16, hints:[6]};
  return {line:null, hints:[]};
}

// ===== Render Tree + Lines =====
function renderTreeAndLines(step) {
  const tree = step.tree;
  treeEl.innerHTML = "";
  let maxIdx = -1;
  tree.forEach((_, k) => { if (k > maxIdx) maxIdx = k; });
  if (maxIdx < 0) { treeEl.textContent = "∅"; linesSvg.innerHTML=""; return; }
  const maxLevel = Math.floor(Math.log2(maxIdx + 1));
  for (let lvl=0; lvl<=maxLevel; lvl++) {
    const cols = Math.pow(2, lvl);
    const row = document.createElement('div');
    row.className = 'level';
    row.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    for (let c=0; c<cols; c++) {
      const idx = (1<<lvl) - 1 + c;
      const cell = document.createElement('div');
      cell.className = 'slot';
      if (tree.has(idx)) {
        const node = document.createElement('div');
        node.className = 'node';
        node.textContent = tree.get(idx);
        node.dataset.idx = idx;
        if (step.highlight === idx) node.classList.add('current');
        if (step.enq && step.enq.includes(idx)) node.classList.add('enq');
        cell.appendChild(node);
      }
      row.appendChild(cell);
    }
    treeEl.appendChild(row);
  }
  const rect = treeEl.getBoundingClientRect();
  const w = Math.ceil(rect.width);
  const h = Math.ceil(rect.height);
  linesSvg.setAttribute('width', w);
  linesSvg.setAttribute('height', h);
  linesSvg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  linesSvg.style.width = w + 'px';
  linesSvg.style.height = h + 'px';
  linesSvg.innerHTML = "";

  const nodes = Array.from(treeEl.querySelectorAll('.node'));
  const pos = new Map();
  const treeRect = treeEl.getBoundingClientRect();
  nodes.forEach(n => {
    const r = n.getBoundingClientRect();
    const cx = r.left - treeRect.left + r.width/2;
    const cy = r.top - treeRect.top + r.height/2;
    pos.set(parseInt(n.dataset.idx,10), {cx, cy});
  });

  const NS = "http://www.w3.org/2000/svg";
  function line(x1,y1,x2,y2) {
    const l = document.createElementNS(NS, 'line');
    l.setAttribute('x1', x1); l.setAttribute('y1', y1);
    l.setAttribute('x2', x2); l.setAttribute('y2', y2);
    l.setAttribute('stroke', '#999');
    l.setAttribute('stroke-width', '2');
    linesSvg.appendChild(l);
  }

  pos.forEach(({cx,cy}, i) => {
    const li = 2*i + 1, ri = 2*i + 2;
    if (pos.has(li)) { const p = pos.get(li); line(cx, cy+20, p.cx, p.cy-20); }
    if (pos.has(ri)) { const p = pos.get(ri); line(cx, cy+20, p.cx, p.cy-20); }
  });
}

// ===== Queue render =====
function renderQueue(q) {
  queueEl.innerHTML = "";
  if (!q.length) { queueEl.textContent = "∅"; return; }
  q.forEach(({val, idx}, k) => {
    const el = document.createElement('div');
    el.className = 'qitem';
    el.innerHTML = `<strong>${val}</strong><span class="qidx">, idx=${idx}</span>`;
    queueEl.appendChild(el);
    if (k < q.length-1) {
      const dot = document.createElement('span');
      dot.className = 'sep';
      dot.textContent = "→";
      queueEl.appendChild(dot);
    }
  });
}

// ===== Simulation State =====
let steps = [];
let cur = 0;
let timer = null;

function render(i) {
  const s = steps[i];
  statusEl.textContent = s.done ? "Done" : `Step ${i+1} / ${steps.length}`;

  renderTreeAndLines(s);
  renderQueue(s.queue);

  vSize.textContent = (s.size ?? "—");
  vFirst.textContent = (s.first ?? "—");
  vLast.textContent = (s.last ?? "—");
  vMax.textContent = (s.maxw ?? "—");
  vIdx.textContent = (s.curIdx ?? (s.highlight ?? "—"));
  vVal.textContent = (s.curVal ?? "—");
  vPhase.textContent = (s.phase ?? "—");
  vSub.textContent = (s.sub ?? "—");

  if (s.first != null && s.last != null) {
    const w = s.last - s.first + 1;
    formulaEvalEl.textContent = `${s.last} - ${s.first} + 1 = ${w}`;
  } else {
    formulaEvalEl.textContent = "—";
  }
  noteEl.textContent = s.note || "—";

  const {line, hints} = pointerForStep(s, document.getElementById('micro').checked);
  setPointer(line, hints);
}

function goto(i) { cur = Math.max(0, Math.min(steps.length-1, i)); render(cur); }
function stopTimer() { if (timer) { clearInterval(timer); timer = null; document.getElementById('play').textContent = 'Play'; } }
function startTimer() {
  stopTimer();
  document.getElementById('play').textContent = 'Pause';
  const spd = parseInt(document.getElementById('speed').value, 10);
  timer = setInterval(() => { if (cur >= steps.length-1) { stopTimer(); return; } goto(cur+1); }, spd);
}

// Controls
document.getElementById('first').onclick = () => { stopTimer(); goto(0); };
document.getElementById('prev').onclick  = () => { stopTimer(); goto(cur-1); };
document.getElementById('next').onclick  = () => { stopTimer(); goto(cur+1); };
document.getElementById('last').onclick  = () => { stopTimer(); goto(steps.length-1); };
document.getElementById('play').onclick  = () => { if (timer) stopTimer(); else { if (cur >= steps.length-1) goto(0); startTimer(); } };
document.getElementById('speed').oninput = () => { if (timer) startTimer(); };

// Load & presets
presetSel.onchange = () => { const p = presetSel.value; if (p !== 'custom') arrInput.value = PRESETS[p]; };
function runBuild() {
  const arr = parseArray(arrInput.value);
  const err = document.getElementById('err');
  if (!arr) { err.textContent = "Invalid array. Use JSON-like: [1,3,2,5,3,null,9]"; return false; }
  err.textContent = "";
  steps = buildSteps(arr, document.getElementById('micro').checked);
  goto(0);
  return true;
}
loadBtn.onclick = () => { stopTimer(); runBuild(); };
document.getElementById('micro').onchange = () => { stopTimer(); runBuild(); };

// Auto-load initial
runBuild();

// Re-draw lines on resize (layout may change)
window.addEventListener('resize', () => render(cur));
</script>
</body>
</html>
