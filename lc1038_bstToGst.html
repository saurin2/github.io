
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>LeetCode 1038 — BST to Greater Sum Tree (Interactive, v2)</title>
<style>
  :root { --bg:#fff; --fg:#111; --muted:#666; --accent1:#1f77b4; --accent2:#ff7f0e; --accent3:#2ca02c; --box:#222; }
  body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 20px; color: var(--fg); background: var(--bg); }
  .container { max-width: 1280px; margin: 0 auto; }
  h2 { margin-bottom: 6px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin: 12px 0; }
  input[type="text"] { padding: 6px 8px; min-width: 360px; }
  select, button, label { padding: 6px 10px; font-size: 14px; }
  .status { margin-left: 6px; }
  .layout { display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 16px; align-items: start; }
  .panel { border: 1px solid #ddd; padding: 10px; border-radius: 10px; background:#fafafa; }
  .panel h3 { margin: 8px 0; font-size: 16px; }

  .treeCanvas { position: relative; }
  .tree { padding: 10px; border-radius: 10px; }
  .level { display:grid; gap: 12px; align-items:center; margin: 8px 0; }
  .node { width: 42px; height: 42px; border-radius: 50%; border: 2px solid var(--box);
          display:flex; align-items:center; justify-content:center; font-weight:600; background:#fff;
          margin:0 auto; position: relative; transition: transform .15s; }
  .node.current { outline: 3px solid var(--accent3); transform: scale(1.04); background: #f6fff6; }
  .slot { min-height: 52px; }
  .legend { font-size: 12px; color: #555; margin-top: 8px; }

  .vars { display:grid; grid-template-columns: 1fr 1fr; gap: 6px; }
  .vrow { display:flex; justify-content: space-between; background:#fff; border:1px solid #ddd; border-radius:6px; padding:6px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  .stack { display:flex; gap:6px; flex-wrap:wrap; }
  .frame { background:#fff; border:1px solid #aaa; border-radius:6px; padding:4px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .frame.cur { background:#e7f7ff; border-color:#60a5fa; }

  /* Code box */
  .codebox { background:#0c0f14; color:#cde3ff; border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px;
             overflow-x: auto; }
  .codeline { display: grid; grid-template-columns: 32px 18px auto; gap: 8px; align-items: start; padding: 2px 6px; border-radius: 6px; }
  .codeline .ln { color:#7799bb; text-align: right; }
  .codeline .ptr { width: 18px; text-align: center; color: #9cff57; }
  .codeline .code-text { white-space: pre; }
  .codeline.active { background: #122033; }
  .codeline.hint { background: #0f1723; }

  .svg-lines { position:absolute; left:0; top:0; pointer-events:none; }
</style>
</head>
<body>
<div class="container">
  <h2>LeetCode 1038 — Binary Search Tree to Greater Sum Tree (Interactive, v2)</h2>
  <div class="row">
    <label><strong>Choose test case:</strong>
      <select id="preset">
        <option value="ex1">Example 1: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</option>
        <option value="ex2">Example 2: [0,null,1]</option>
        <option value="ex3">Example 3: [1,0,2]</option>
        <option value="custom">Custom</option>
      </select>
    </label>
    <input id="arr" type="text" value="[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]" />
    <button id="load">Load</button>
    <label><input type="checkbox" id="micro" checked> Micro-steps</label>
    <span id="err" style="color:#b00;"></span>
  </div>

  <div class="controls">
    <button id="first">&laquo; First</button>
    <button id="prev">&lsaquo; Prev</button>
    <span class="status" id="status">Step 0 / 0</span>
    <button id="next">Next &rsaquo;</button>
    <button id="last">Last &raquo;</button>
    <button id="play">Play</button>
    <label style="margin-left:10px;">Speed <input id="speed" type="range" min="150" max="1500" step="50" value="600"></label>
  </div>

  <div class="layout">
    <!-- Left: tree + state -->
    <div>
      <div class="panel">
        <h3>Tree (complete-binary layout by index)</h3>
        <div class="treeCanvas" id="treeCanvas">
          <div id="tree" class="tree"></div>
          <svg id="lines" class="svg-lines"></svg>
        </div>
        <div class="legend">Root at 0, left = 2i+1, right = 2i+2. Values update in-place during reverse-inorder (right → node → left).</div>
      </div>

      <div class="panel">
        <h3>State</h3>
        <div class="vars">
          <div class="vrow"><span>cursum</span><span id="v_cursum">-</span></div>
          <div class="vrow"><span>temp</span><span id="v_temp">-</span></div>
          <div class="vrow"><span>current idx</span><span id="v_idx">-</span></div>
          <div class="vrow"><span>current val</span><span id="v_val">-</span></div>
          <div class="vrow"><span>phase</span><span id="v_phase">-</span></div>
          <div class="vrow"><span>substep</span><span id="v_sub">-</span></div>
        </div>
        <div style="margin-top:8px;">
          <div><span class="em">Call stack</span> (top = rightmost):</div>
          <div class="stack" id="stack"></div>
        </div>
      </div>
    </div>

    <!-- Right: code + notes -->
    <div>
      <div class="panel">
        <h3>Code (gdb-style pointer)</h3>
        <div id="code" class="codebox"></div>
      </div>
      <div class="panel">
        <h3>Notes</h3>
        <div id="note" class="vrow" style="display:block;">—</div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h3>Given C++ (reference)</h3>
<pre class="codebox" style="white-space:pre; overflow:auto;"><code>class Solution {
public:
    void dfs(TreeNode* root,int &cursum) {
        if(!root) return;
        dfs(root->right,cursum);
        int temp=root->val;
        root->val+=cursum;
        cursum+=temp;
        dfs(root->left,cursum);
    }
    TreeNode* bstToGst(TreeNode* root) {
        int cursum=0;
        if(!root) return root;
        dfs(root,cursum);
        return root;
    }
};</code></pre>
  </div>
</div>

<script>
// ===== Presets =====
const PRESETS = {
  ex1: "[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]",
  ex2: "[0,null,1]",
  ex3: "[1,0,2]"
};

// ===== Code lines for pointer =====
const CODE_LINES = [
  "void dfs(TreeNode* root, int &cursum) {",
  "    if (!root) return;",
  "    dfs(root->right, cursum);",
  "    int temp = root->val;",
  "    root->val += cursum;",
  "    cursum += temp;",
  "    dfs(root->left, cursum);",
  "}",
  "TreeNode* bstToGst(TreeNode* root) {",
  "    int cursum = 0;",
  "    if (!root) return root;",
  "    dfs(root, cursum);",
  "    return root;",
  "}"
];

// ===== Parse helpers =====
function parseArray(text) {
  try {
    let t = text.trim();
    if (!t.startsWith("[")) t = "[" + t + "]";
    const arr = JSON.parse(t.replace(/\\bnull\\b/g, "null"));
    if (!Array.isArray(arr)) return null;
    return arr;
  } catch { return null; }
}

// Build index->value map (mutable values)
function buildIndexMap(arr) {
  const map = new Map();
  arr.forEach((v, i) => { if (v !== null && v !== undefined) map.set(i, v); });
  return map;
}

// Deep copy of a Map<number,number>
function cloneMap(m) {
  const c = new Map();
  m.forEach((v,k)=>c.set(k,v));
  return c;
}

// ===== Step builder: simulate dfs reverse-inorder; store full map snapshot every step =====
function buildSteps(arr, micro) {
  const idxMap = buildIndexMap(arr);
  const steps = [];
  let cursum = 0;

  // helper to push step with snapshot
  function pushStep(obj) {
    steps.push(Object.assign({ map: cloneMap(idxMap) }, obj));
  }

  // bstToGst prologue
  pushStep({note:"Enter bstToGst", phase:"btg-enter", line:9, idx:null, val:null, cursum, temp:null, stack:[]});
  if (!idxMap.has(0)) {
    pushStep({note:"root is null → return", phase:"btg-null", line:11, idx:null, val:null, cursum, temp:null, stack:[]});
    pushStep({note:"Done.", phase:"done", line:13, stack:[], done:true});
    return steps;
  }
  pushStep({note:"cursum = 0", phase:"btg-init", line:10, idx:null, val:null, cursum, temp:null, stack:[]});
  pushStep({note:"Call dfs(root, cursum)", phase:"btg-call", line:12, idx:0, val:idxMap.get(0), cursum, temp:null, stack:[0]});

  function dfs(idx, stack) {
    pushStep({note:`dfs(idx=${idx})`, phase:"dfs-enter", line:1, idx, val:idxMap.get(idx), cursum, temp:null, stack:[...stack]});
    if (!idxMap.has(idx)) {
      pushStep({note:"if (!root) return;", phase:"dfs-null", line:2, idx:null, val:null, cursum, temp:null, stack:[...stack]});
      return;
    }
    pushStep({note:"Check !root (false)", phase:"dfs-check", line:2, idx, val:idxMap.get(idx), cursum, temp:null, stack:[...stack]});

    const ri = 2*idx + 2;
    pushStep({note:"Recurse right", phase:"dfs-right", line:3, idx, val:idxMap.get(idx), cursum, temp:null, stack:[...stack]});
    if (idxMap.has(ri)) {
      stack.push(ri); dfs(ri, stack); stack.pop();
    } else {
      pushStep({note:"dfs(right) hits null → return", phase:"dfs-right-null", line:3, idx:null, val:null, cursum, temp:null, stack:[...stack]});
    }

    const temp = idxMap.get(idx);
    if (micro) {
      pushStep({note:`int temp = ${temp}`, phase:"dfs-temp", line:4, idx, val:idxMap.get(idx), cursum, temp, stack:[...stack]});
      idxMap.set(idx, idxMap.get(idx) + cursum);
      pushStep({note:`root->val += cursum → ${idxMap.get(idx)}`, phase:"dfs-add", line:5, idx, val:idxMap.get(idx), cursum, temp, stack:[...stack]});
      cursum += temp;
      pushStep({note:`cursum += temp → ${cursum}`, phase:"dfs-cursum", line:6, idx, val:idxMap.get(idx), cursum, temp, stack:[...stack]});
    } else {
      // collapsed: perform all at once but record a single step
      idxMap.set(idx, idxMap.get(idx) + cursum);
      const newVal = idxMap.get(idx);
      cursum += temp;
      pushStep({note:`update node: temp=${temp}, newVal=${newVal}, cursum=${cursum}`, phase:"dfs-update", line:4, idx, val:newVal, cursum, temp, stack:[...stack]});
    }

    const li = 2*idx + 1;
    pushStep({note:"Recurse left", phase:"dfs-left", line:7, idx, val:idxMap.get(idx), cursum, temp:null, stack:[...stack]});
    if (idxMap.has(li)) {
      stack.push(li); dfs(li, stack); stack.pop();
    } else {
      pushStep({note:"dfs(left) hits null → return", phase:"dfs-left-null", line:7, idx:null, val:null, cursum, temp:null, stack:[...stack]});
    }

    pushStep({note:"return;", phase:"dfs-ret", line:8, idx, val:idxMap.get(idx), cursum, temp:null, stack:[...stack]});
  }

  dfs(0, [0]);

  pushStep({note:"Back to bstToGst", phase:"btg-back", line:12, idx:null, val:null, cursum, temp:null, stack:[]});
  pushStep({note:"return root", phase:"btg-ret", line:13, idx:null, val:null, cursum, temp:null, stack:[], done:true});

  return steps;
}

// ===== DOM & Rendering =====
const presetSel = document.getElementById('preset');
const arrInput = document.getElementById('arr');
const microChk = document.getElementById('micro');
const loadBtn = document.getElementById('load');
const statusEl = document.getElementById('status');

const treeEl = document.getElementById('tree');
const linesSvg = document.getElementById('lines');
const vCursum = document.getElementById('v_cursum');
const vTemp = document.getElementById('v_temp');
const vIdx = document.getElementById('v_idx');
const vVal = document.getElementById('v_val');
const vPhase = document.getElementById('v_phase');
const vSub = document.getElementById('v_sub');
const stackEl = document.getElementById('stack');
const noteEl = document.getElementById('note');
const codeEl = document.getElementById('code');

// Build code panel
function buildCode() {
  codeEl.innerHTML = "";
  CODE_LINES.forEach((txt, i) => {
    const d = document.createElement('div');
    d.className = 'codeline';
    d.dataset.ln = (i+1);
    d.innerHTML = `<div class="ln">${i+1}</div><div class="ptr"> </div><div class="code-text">${txt}</div>`;
    codeEl.appendChild(d);
  });
}
buildCode();

function setPointer(line, hints=[]) {
  const lines = codeEl.querySelectorAll('.codeline');
  lines.forEach(l => { l.classList.remove('active','hint'); l.querySelector('.ptr').textContent = ' '; });
  if (line != null) {
    const el = codeEl.querySelector(`.codeline[data-ln="${line}"]`);
    if (el) { el.classList.add('active'); el.querySelector('.ptr').textContent = '›'; }
  }
  hints.forEach(h => { const el = codeEl.querySelector(`.codeline[data-ln="${h}"]`); if (el) el.classList.add('hint'); });
}

function pointerForStep(s) {
  const map = {
    "btg-enter": 9, "btg-init": 10, "btg-null": 11, "btg-call": 12, "btg-back": 12, "btg-ret": 13,
    "dfs-enter": 1, "dfs-null": 2, "dfs-check": 2, "dfs-right": 3,
    "dfs-temp": 4, "dfs-add": 5, "dfs-cursum": 6, "dfs-update": 4, "dfs-left": 7, "dfs-ret": 8,
    "dfs-right-null": 3, "dfs-left-null": 7
  };
  const line = map[s.phase] ?? null;
  let hints = [];
  if (s.phase === "dfs-enter" || s.phase === "dfs-check") hints = [2];
  if (s.phase === "dfs-right") hints = [3];
  if (s.phase === "dfs-left") hints = [7];
  return { line, hints };
}

// Render tree & lines using the per-step snapshot map
function renderTreeFromMap(step) {
  const map = step.map;
  treeEl.innerHTML = "";
  linesSvg.innerHTML = "";

  let maxIdx = -1; map.forEach((_, k) => { if (k > maxIdx) maxIdx = k; });
  if (maxIdx < 0) { treeEl.textContent = "∅"; return; }
  const maxLevel = Math.floor(Math.log2(maxIdx + 1));

  for (let lvl=0; lvl<=maxLevel; lvl++) {
    const cols = Math.pow(2, lvl);
    const row = document.createElement('div');
    row.className = 'level';
    row.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    for (let c=0; c<cols; c++) {
      const idx = (1<<lvl) - 1 + c;
      const cell = document.createElement('div');
      cell.className = 'slot';
      if (map.has(idx)) {
        const node = document.createElement('div');
        node.className = 'node';
        node.textContent = map.get(idx);
        node.dataset.idx = idx;
        if (step.idx === idx) node.classList.add('current');
        cell.appendChild(node);
      }
      row.appendChild(cell);
    }
    treeEl.appendChild(row);
  }

  // draw lines
  const rect = treeEl.getBoundingClientRect();
  const w = Math.ceil(rect.width), h = Math.ceil(rect.height);
  linesSvg.setAttribute('width', w); linesSvg.setAttribute('height', h);
  linesSvg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  linesSvg.style.width = w + 'px'; linesSvg.style.height = h + 'px';

  const nodes = Array.from(treeEl.querySelectorAll('.node'));
  const pos = new Map();
  const treeRect = treeEl.getBoundingClientRect();
  nodes.forEach(n => {
    const r = n.getBoundingClientRect();
    const cx = r.left - treeRect.left + r.width/2;
    const cy = r.top - treeRect.top + r.height/2;
    pos.set(parseInt(n.dataset.idx,10), {cx, cy});
  });
  const NS = "http://www.w3.org/2000/svg";
  function line(x1,y1,x2,y2) {
    const l = document.createElementNS(NS, 'line');
    l.setAttribute('x1', x1); l.setAttribute('y1', y1);
    l.setAttribute('x2', x2); l.setAttribute('y2', y2);
    l.setAttribute('stroke', '#999'); l.setAttribute('stroke-width', '2');
    linesSvg.appendChild(l);
  }
  pos.forEach(({cx,cy}, i) => {
    const li = 2*i + 1, ri = 2*i + 2;
    if (pos.has(li)) { const p = pos.get(li); line(cx, cy+20, p.cx, p.cy-20); }
    if (pos.has(ri)) { const p = pos.get(ri); line(cx, cy+20, p.cx, p.cy-20); }
  });
}

function renderStack(stack) {
  stackEl.innerHTML = "";
  if (!stack || !stack.length) { stackEl.textContent = "∅"; return; }
  stack.forEach((s, i) => {
    const el = document.createElement('div');
    el.className = 'frame' + (i === stack.length-1 ? ' cur' : '');
    el.textContent = `dfs(idx=${s})`;
    stackEl.appendChild(el);
  });
}

let steps = [];
let cur = 0;
let timer = null;

function render(i) {
  const s = steps[i];
  statusEl.textContent = s && s.done ? "Done" : `Step ${i+1} / ${steps.length}`;
  renderTreeFromMap(s);
  vCursum.textContent = s.cursum ?? "—";
  vTemp.textContent = s.temp ?? "—";
  vIdx.textContent = (s.idx ?? "—");
  vVal.textContent = (s.val ?? "—");
  vPhase.textContent = s.phase ?? "—";
  vSub.textContent = s.sub ?? "—";
  renderStack(s.stack);
  noteEl.textContent = s.note || "—";

  const {line, hints} = pointerForStep(s);
  setPointer(line, hints);
}

function goto(i) { cur = Math.max(0, Math.min(steps.length-1, i)); render(cur); }
function stopTimer() { if (timer) { clearInterval(timer); timer = null; document.getElementById('play').textContent = 'Play'; } }
function startTimer() {
  stopTimer();
  document.getElementById('play').textContent = 'Pause';
  const spd = parseInt(document.getElementById('speed').value, 10);
  timer = setInterval(() => { if (cur >= steps.length-1) { stopTimer(); return; } goto(cur+1); }, spd);
}

// Controls
document.getElementById('first').onclick = () => { stopTimer(); goto(0); };
document.getElementById('prev').onclick  = () => { stopTimer(); goto(cur-1); };
document.getElementById('next').onclick  = () => { stopTimer(); goto(cur+1); };
document.getElementById('last').onclick  = () => { stopTimer(); goto(steps.length-1); };
document.getElementById('play').onclick  = () => { if (timer) stopTimer(); else { if (cur >= steps.length-1) goto(0); startTimer(); } };
document.getElementById('speed').oninput = () => { if (timer) startTimer(); };

// Load & presets
const presetSelEl = document.getElementById('preset');
presetSelEl.onchange = () => { const p = presetSelEl.value; if (p !== 'custom') arrInput.value = PRESETS[p]; };
function runBuild() {
  const arr = parseArray(arrInput.value);
  const err = document.getElementById('err');
  if (!arr) { err.textContent = "Invalid array. Use JSON-like: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]"; return false; }
  err.textContent = "";
  steps = buildSteps(arr, document.getElementById('micro').checked);
  goto(0);
  return true;
}
loadBtn.onclick = () => { stopTimer(); runBuild(); };
document.getElementById('micro').onchange = () => { stopTimer(); runBuild(); };

// Auto-load initial
runBuild();

// Re-draw lines on resize
window.addEventListener('resize', () => render(cur));
</script>
</body>
</html>
